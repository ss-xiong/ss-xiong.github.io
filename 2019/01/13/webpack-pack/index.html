<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="前端开发、Golang、学习">
    <meta name="author" content="ss-xiong">
    <meta name="keywords" content="js,html,css,golang,数据库,架构">
    <title>浅析webpack打包结构 ~ 有个松子&#39;s Blog</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/tomorrow-night-eighties.min.css">
    
</head>

<body>
  <header style="height: 55vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>有个松子&#39;s Blog</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/category/">Category</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("http://pp86kugxp.bkt.clouddn.com/blog/images/webpack.png")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">浅析webpack打包结构</p>
            <br>
            
            <p>星期日, 一月 13日 2019, 2:10 下午</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="post-content py-5 z-depth-3 main">
                <h1 id="浅析webpack打包结构"><a href="#浅析webpack打包结构" class="headerlink" title="浅析webpack打包结构"></a>浅析webpack打包结构</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>众所周知，webpack有一句名言，叫做“bundle everything”。我们在进行前端开发的时候经常把代码分成各个模块，然后利用webpack将各个模块打包。在一个项目中，通常一个模块通过引入另一个模块暴露出来的入口，进行模块间的交流。那么如果在另一个项目中，想用到这个项目中的某个模块该怎么办呢？</p>
</blockquote>
<blockquote>
<p>有同学会说，我可以把那个模块以依赖的方式引进来一起打包不就好了。但是如果这个项目只是想简单通过引入js的方式用一下这个模块中的方法呢？</p>
</blockquote>
<p>一起来看一下下面的场景吧</p>
<p>首先是一个简单的webpack配置文件，一个入口，一个出口</p>
<pre><code>...
// 入口文件
entry: path.resolve(__dirname, &#39;src/index.js&#39;), 

//出口文件
output: { 
    filename: &quot;index.js&quot;,
    path: path.resolve(__dirname, &#39;build/&#39;),
    publicPath: &#39;&#39;
},
...
</code></pre><p>在index.js文件中简单定义了一个方法hello，然后将方法名暴露出去</p>
<pre><code>var hello = function() {
    console.log(&#39;helloWorld&#39;);
}
export default hello
</code></pre><p>之后在index.html引入打包好的js文件</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;
</code></pre><p>如果直接在html里调用index封装好的方法呢？会发现这个hello不存在，嗯，那么webpack把hello放到哪里去了呢？我们怎么才能调到它呢？</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    hello() //Uncaught ReferenceError: hello is not defined
&lt;/script&gt;
</code></pre><h2 id="webpack打包结构"><a href="#webpack打包结构" class="headerlink" title="webpack打包结构"></a>webpack打包结构</h2><p>接下来我们就一起来看看webpack对我们的代码做了什么。。。<br>打开打包后的代码可以看到，打包后的js结构是一个自执行函数，入参是一个模块组成的对象，简化如下：</p>
<pre><code>(function(modules) {
    // webpack模块
})({
    // 模块对象们
})
</code></pre><p>下面是webpack打包出来的一堆东西，webpack首先在里面定义了一堆方法，最后返回了<strong><strong>webpack_require</strong></strong>这个方法，入参是<strong>“./src/index.js”</strong>，我们再来看<strong>webpack_require</strong>是怎么定义的。首先根据moduleId，也就是”./src/index.js”判断这个模块是否在模块缓存中，如果在就返回这个模块的输出；如果不在就声明一个模块对象，并放入模块缓存中，之后有一个很关键的一步，<strong>modules[moduleId].call(module.exports, module, module.exports, <strong>webpack_require</strong>)</strong>，它将模块的作用域指向了声明的模块输出中，也就是说模块的作用域不再暴露在全局作用域下了，也就没办法通过window.xxx调用模块中的方法了。方法在最后返回了模块输出的内容。</p>
<p>webpack模块</p>
<pre><code>(function(modules) {

    //模块缓存
    var installedModules = {};

    //定义__webpack_require__方法
    function __webpack_require__(moduleId) {

        //判断模块是否存在
        if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
        }
        //定义模块并放入缓存
        var module = installedModules[moduleId] = {
            i: moduleId, //模块id
            l: false, //是否加载模块
            exports: {} //输出对象暴露内容
        };

        //将模块作用域指向module.exports
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

        //加载完成
        module.l = true;

        //输出模块暴露内容
        return module.exports;
    }

    __webpack_require__.r = function(exports) {

        //ES6 引入的一种新的原始数据类型，它是 JavaScript 语言的第七种数据类型。Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是字符串，另一种就是新增的 Symbol 类型。
        if (typeof Symbol !== &#39;undefined&#39; &amp;&amp; Symbol.toStringTag) {
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: &#39;Module&#39;
            });
        }

        //exports[&#39;__esModule&#39;]  //true
        Object.defineProperty(exports, &#39;__esModule&#39;, {
            value: true
        });
    };

    ....

    return __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;);
})
</code></pre><p>从代码中可以看到这个webpack模块的入参是这么一个对象，对象里面结构类似于<br>{路径: 方法}，方法有三个参数，从字面意思上看分别是模块、模块输出、模块依赖</p>
<p>模块对象</p>
<pre><code>({
    &quot;./src/index.js&quot;: (function(module, __webpack_exports__, __webpack_require__) {
            &quot;use strict&quot;;
            __webpack_require__.r(__webpack_exports__);

            var hello = function() {
                console.log(&#39;helloWorld&#39;);
            };
            __webpack_exports__[&quot;default&quot;] = (hello);
        })
})
</code></pre><p>将代码体简化后的效果如下</p>
<pre><code>(function(modules) {
    // webpack模块
})({
    moduleId: (function(module, exports, require) {
        var hello =  ...
        exports[&#39;default&#39;] = (hello);
    })
})
</code></pre><p>那么我们怎么才能在html里面访问这个私有模块里面的方法呢？我陷入了沉思。。。因为在html里面调用的方法需要是挂载下window方可访问，那么我们是不是可以通过给这个自执行函数赋给一个变量，这样就可以在全局访问到这个函数了，代码如下：</p>
<pre><code>var name = (function(modules) {
    // webpack模块
})({
    moduleId: (function(module, exports, require) {
        var hello =  ...
        exports[&#39;default&#39;] = (hello);
    })
})
</code></pre><p>问题来了，因为在代码中，我们是将hello方法放在了default下，就是说需要通过对象输出的default属性访问，改后的代码如下：</p>
<pre><code>var name = (function(modules) {
    // webpack模块
})({
    moduleId: (function(module, exports, require) {
        var hello =  ...
        exports[&#39;default&#39;] = (hello);
    })
})[&#39;default&#39;]
</code></pre><p>如果我们每次在用模块里面的方法时都要再手动给它赋一个值，然后再查看那个模块方法是不是在default里挂着，这样重复的工作是我们程序媛不愿意看到的。<br>那么在webpack中有没有一种办法可以让我们把打包好的代码挂载在window下呢？我又陷入了沉思。。。万幸的是万能的webpack真的给我们提供了这样的途径</p>
<h2 id="library"><a href="#library" class="headerlink" title="library"></a>library</h2><p>The variable MyLibrary will be bound with the return value of your entry file, if the resulting output is included as a script tag in an HTML page.</p>
<p>这是官方文档上的一段话，翻译成中文大概意思就是说，如果想在html中通过script引入我们打包好的方法，就用library吧，它可以把你的包放到window下，然后你就可以拿来用了，嗯，配置文件就是这样的</p>
<p>webpack.config.js</p>
<pre><code>...
entry: path.resolve(__dirname, &#39;src/index.js&#39;),
output: {
    ...
    library: &#39;hello&#39;, //变量名为hello
    libraryExport: &quot;default&quot; //输出default下的东西
    ...
},
...
</code></pre><p>然后webpack就给我们打包出来啦，当当当~</p>
<pre><code>var hello = (function(modules) {
    // webpack模块
})({
    // 模块对象们
})[&#39;default&#39;]
</code></pre><h2 id="libraryTarget"><a href="#libraryTarget" class="headerlink" title="libraryTarget"></a>libraryTarget</h2><p>webpack还给我们提供了一个参数libraryTarget，这货又是干嘛的？它其实相当于是参数定义的方式，比如默认的var，window，this，amd，umd……<br>webpack.config.js</p>
<pre><code>...
entry: path.resolve(__dirname, &#39;src/index.js&#39;),
output: {
    ...
    library: &#39;hello&#39;,
    libraryExport: &quot;default&quot;,
    libraryTarget: &#39;xxx&#39; // 它可以有很多入参
    ...
},
...
</code></pre><ul>
<li><p>var(default)</p>
</li>
<li><p>window</p>
<pre><code>window[&quot;hello&quot;] = (function(modules) {
  // webpack模块
})({
  // 模块对象们
})[&#39;default&#39;]
</code></pre></li>
<li><p>this</p>
<pre><code>this[&quot;hello&quot;] = (function(modules) {
  // webpack模块
})({
  // 模块对象们
})[&#39;default&#39;]
</code></pre></li>
<li><p>amd(事情发生了有趣的变化)<br><em>异步模块定义（Asynchronous module definition），是 RequireJS 在推广过程中对模块定义的规范化产出。</em></p>
<pre><code>define(&quot;hello&quot;, [], function() {
  return (function(modules) {
      // webpack模块
  })({
      // 模块对象们
  })[&#39;default&#39;]
})
</code></pre></li>
<li><p>umd(似乎更有趣了)</p>
<pre><code>(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === &#39;object&#39; &amp;&amp; typeof module === &#39;object&#39;)
      module.exports = factory();
  else if (typeof define === &#39;function&#39; &amp;&amp; define.amd)
      define([], factory);
  else if (typeof exports === &#39;object&#39;)
      exports[&quot;hello&quot;] = factory();
  else
      root[&quot;hello&quot;] = factory();
})(window, function() {
  return (function(modules) {
      // webpack模块
  })({
      // 模块对象们
  })[&#39;default&#39;]
})
</code></pre></li>
</ul>
<p>umdNamedDefine将amd方式中的define默认的default改为library的名字<br>webpack.config.js</p>
<pre><code>...
entry: path.resolve(__dirname, &#39;src/index.js&#39;),
output: {
    ...
    library: &#39;hello&#39;,
    libraryExport: &quot;default&quot;,
    libraryTarget: &#39;umd&#39;,
    umdNamedDefine: true,
    ...
},
...
</code></pre><pre><code>(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === &#39;object&#39; &amp;&amp; typeof module === &#39;object&#39;)
        module.exports = factory();
    else if (typeof define === &#39;function&#39; &amp;&amp; define.amd)
        define(&#39;hello&#39;, [], factory);
    else if (typeof exports === &#39;object&#39;)
        exports[&quot;hello&quot;] = factory();
    else
        root[&quot;hello&quot;] = factory();
})(window, function() {
    return (function(modules) {
        // webpack模块
    })({
        // 模块对象们
    })[&#39;default&#39;]
})
</code></pre><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>webpack通过打包模块，并放入私有作用域中，其实是鼓励大家以这样的方式去开发的。减少对公共作用域的污染，也保证了程序的健壮性。但是对于曾经写过的一些模块，我想在另外的项目中用到，比如一个活动页，既然webpack都提供了这样的方式，那么就想用就用吧</p>

                <hr>
                <div>
                    <p>
                         
                        <span class="badge badge-light">#&nbsp;Webpack</span>
                        &nbsp;
                        
                    </p>
                </div>
                <br>
                
                    <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GNU GPL协议</a> 。转载请注明出处！</p>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">

    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk-container" style="width: 100%;">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({
            clientID: '5611c27bda66a636dd8f',
            clientSecret: 'f646fdf27383da58cc1da5a591160a0530b7bc38',
            id: location.pathname,
            repo: 'ss-xiong-blog-comments',
            owner: 'ss-xiong',
            admin: 'ss-xiong',
            labels: ['gitalk'],
            distractionFreeMode: 'true',
            createIssueManually: 'true',
            page: '20',
        })
        gitalk.render('gitalk-container')
    </script>
</div>
 
</div>
  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    
    <a href="https://github.com/ss-xiong" target="_blank">
      <b>SS-XIONG&copy;</b>
    </a>
    
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont">😘</i>
    <a href="https://github.com/invom/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    
    <script src="/js/post.js"></script>
    
      <script src="/js/plugins/prettify.js"></script>
      <script>
          $(document).ready(function(){
              $('pre').addClass('prettyprint linenums');
              prettyPrint();
          })
      </script>
    
  
</body>
</html>