<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="前端开发、Golang、学习">
    <meta name="author" content="ss-xiong">
    <meta name="keywords" content="js,html,css,golang,数据库,架构">
    <title>GO字符串相关处理-strings包 ~ 有个松子&#39;s Blog</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/tomorrow-night-eighties.min.css">
    
</head>

<body>
  <header style="height: 55vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>有个松子&#39;s Blog</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/category/">Category</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("http://pp86kugxp.bkt.clouddn.com/blog/images/golang.png")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">GO字符串相关处理-strings包</p>
            <br>
            
            <p>星期日, 三月 31日 2019, 8:33 晚上</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="post-content py-5 z-depth-3 main">
                <h2 id="GO字符串相关处理-strings包"><a href="#GO字符串相关处理-strings包" class="headerlink" title="GO字符串相关处理-strings包"></a>GO字符串相关处理-strings包</h2><h4 id="1-字符串s中是否存在某个字符或子串"><a href="#1-字符串s中是否存在某个字符或子串" class="headerlink" title="1. 字符串s中是否存在某个字符或子串"></a>1. 字符串s中是否存在某个字符或子串</h4><ul>
<li><code>func Contains(s, substr string) bool</code>，子串substr在s中，返回true</li>
<li><code>func ContainsAny(s, chars string) bool</code>，chars中任何一个Unicode代码点在s中，返回true。也就是说，第二个参数 chars 中任意一个字符（Unicode Code Point）如果在第一个参数 s 中存在，则返回true。</li>
<li><code>func ContainsRune(s string, r rune) bool</code>，Unicode代码点r在s中，返回true</li>
</ul>
<h4 id="2-字符串s中子串出现次数（字符串匹配）"><a href="#2-字符串s中子串出现次数（字符串匹配）" class="headerlink" title="2. 字符串s中子串出现次数（字符串匹配）"></a>2. 字符串s中子串出现次数（字符串匹配）</h4><ul>
<li><p><code>func Count(s, sep string) int</code>，子串sep在s中出现的次数。特别说明一下当 sep 为空时，Count 的返回值是：utf8.RuneCountInString(s) + 1：</p>
<pre><code class="go">fmt.Println(strings.Count(&quot;five&quot;, &quot;&quot;)) // output 5. before &amp; after each rune
</code></pre>
<p>另外，Count 是计算子串在字符串中出现的无重叠的次数（有重叠部分不计数）</p>
</li>
</ul>
<h4 id="3-字符串分割为-string"><a href="#3-字符串分割为-string" class="headerlink" title="3. 字符串分割为[]string"></a>3. 字符串分割为[]string</h4><p>Strings包提供了六个三组分割函数：Fields 和 FieldsFunc、Split 和 SplitAfter、SplitN 和 SplitAfterN用于实现字符串分割为slice。</p>
<ul>
<li><p><code>func Fields(s string) []string</code>，使用空格分割字符串(空格定义：<code>unicode.IsSapce(rune) bool</code>)，结果不包含任何空格</p>
</li>
<li><p><code>func FieldsFunc(s string, f func(rune) bool) []string</code>，使用<code>f func(rune) bool</code>返回true的码点进行分割。可用<code>unicode.IsSapce</code>实现<em>Fields</em>函数:</p>
<pre><code class="go">func Fields(s string) []string {
    return FieldsFunc(s, unicode.IsSpace)
}
</code></pre>
</li>
</ul>
<p>一下几个方法都是内部由genSplit实现的，就放一起了。基本都是接受一个sep，返回一个[]string，如果sep为空，相当于分割成一个个的 UTF-8 字符。Split(s, sep) 和 SplitN(s, sep, -1) 等价；SplitAfter(s, sep) 和 SplitAfterN(s, sep, -1) 等价。</p>
<ul>
<li><code>func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }</code></li>
<li><code>func SplitAfter(s, sep string) []string { return genSplit(s, sep, len(sep), -1) }</code></li>
</ul>
<p>示例：</p>
<pre><code class="go">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;foo,bar,baz&quot;, &quot;,&quot;)) // [&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]
fmt.Printf(&quot;%q\n&quot;, strings.SplitAfter(&quot;foo,bar,baz&quot;, &quot;,&quot;)) // [&quot;foo,&quot; &quot;bar,&quot; &quot;baz,&quot;]
</code></pre>
<ul>
<li><code>func SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }</code></li>
<li><code>func SplitAfterN(s, sep string, n int) []string { return genSplit(s, sep, len(sep), n) }</code></li>
</ul>
<p>带 N 的方法可以通过最后一个参数 n 控制返回的结果中的 slice 中的元素个数，当 n &lt; 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n &gt; 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割。</p>
<h4 id="4-字符串是否含有某个前缀或后缀"><a href="#4-字符串是否含有某个前缀或后缀" class="headerlink" title="4. 字符串是否含有某个前缀或后缀"></a>4. 字符串是否含有某个前缀或后缀</h4><p>这两个函数都挺简单的，源码如下：</p>
<pre><code class="go">// s中是否有prefix前缀
func HasPrefix(s, prefix string) bool {
    return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix
}

// s中是否以suffix结尾
func HasSuffix(s, suffix string) bool {
    return len(s) &gt;= len(suffix) &amp;&amp; s[len(s) - len(suffix):] == suffix
}
</code></pre>
<h4 id="5-字符或子串在字符串中出现的位置"><a href="#5-字符或子串在字符串中出现的位置" class="headerlink" title="5. 字符或子串在字符串中出现的位置"></a>5. 字符或子串在字符串中出现的位置</h4><p>一下这些函数与查找位置相关(从0开始计数)：</p>
<pre><code class="go">// 在s中查找sep的第一次出现，返回第一次出现的索引
func Index(s, sep string) int
// chars中任何一个Unicode代码点在S中首次出现的位置
func IndexAny(s, chars string) int
// 查找字符c在s中第一次出现的位置，其中c满足f(c)返回true
func IndexFunc(s string, f func(rune) bool) int
// Unicode代码点r在s中第一次出现的位置
func IndexRune(s string, r rune) int

// 下面三个函数查找最后一次出现的位置
func LastIndex(s, sep string) int
func LastIndexAny(s, chars string) int
func LastIndexFunc(s string, f func(rune) bool) int
</code></pre>
<h4 id="6-链接-string为字符串"><a href="#6-链接-string为字符串" class="headerlink" title="6. 链接[]string为字符串"></a>6. 链接[]string为字符串</h4><ul>
<li><p><code>func Join(a []string, sep string) string</code>，使用sep将字符串slice连接起来</p>
<p>可以自行实现：</p>
</li>
</ul>
<pre><code class="go">func Join(strs []string, sep string) string{
    if len(strs) == 0 {
        return &quot;&quot;
    }
    if len(strs) == 1 {
        return strs[0]
    }
    var buf bytes.Buffer
    for _, str := range strs {
        buf.WriteString(str)
        buf.WriteString(sep)
    }
    return buf.String()
}
</code></pre>
<p>标准库实现：</p>
<pre><code class="go">func Join(strs []string, sep string) string {
    if len(strs) == 0 {
        return &quot;&quot;
    }
    if len(strs) == 1 {
        return strs[0]
    }
    n := len(sep) * (len(strs) - 1)
    for i := 0; i &lt; len(strs); i ++ {
        n += len(strs[i])
    }
    b := make([]byte, n)
    bp := copy(b, strs[0])
    for _, str := range strs {
        bp += copy(bp, sep)
        bp += copy(bp, str)
    }
    return string(b)
}
</code></pre>
<p>为什么标准库实现没有使用bytes包？原因很简单，butes内部也是通过copy实现的😁</p>
<h4 id="7-字符串重复、替换"><a href="#7-字符串重复、替换" class="headerlink" title="7. 字符串重复、替换"></a>7. 字符串重复、替换</h4><ul>
<li><code>func Repeat(s string, count int) string</code>，字符串s重复count后返回新的字符串</li>
<li><code>func Replace(s, old, new string, n int) string</code>，用new替换s中的old，一共替换n个。如果n&lt;0，则不限制替换次数，简单来说就是全部替换。但是这个方法有局限性，不能一起替换多个字符串，接下来说这个</li>
</ul>
<h4 id="8-Replacer类型"><a href="#8-Replacer类型" class="headerlink" title="8. Replacer类型"></a>8. Replacer类型</h4><p>Replacer是一个结构，没有导出任何字段，实例化通过 <code>func NewReplacer(oldnew ...string) *Replacer</code> 函数进行，其中不定参数 oldnew 是 old-new 对，即进行多个替换。</p>
<p>解决上面说的替换问题：</p>
<pre><code class="go">r := strings.NewReplacer(&quot;&lt;&quot;, &quot;&amp;lt;&quot;, &quot;&gt;&quot;, &quot;&amp;gt;&quot;) // 将&#39;&lt;&#39;替换成&#39;&amp;lt;&#39;，将&#39;&gt;&#39;替换成&#39;&amp;gt;&#39;。
r.Replace(&quot;This is &lt;b&gt;HTML&lt;/b&gt;!&quot;) // This is &amp;lt;b&amp;gt;HTML&amp;lt;/b&amp;gt;!
</code></pre>
<p>另外，Replacer 还提供了另外一个方法：</p>
<pre><code class="go">func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)
</code></pre>
<p>它在替换之后将结果写入 io.Writer 中。</p>
<h4 id="9-Reader类型"><a href="#9-Reader类型" class="headerlink" title="9. Reader类型"></a>9. Reader类型</h4><p>如题，strings包实现了io.Reader接口，也就是实现了io.Reader（Read方法），io.ReaderAt（ReadAt 方法），io.Seeker（Seek 方法），io.WriterTo（WriteTo 方法），io.ByteReader（ReadByte 方法），io.ByteScanner（ReadByte 和 UnreadByte 方法），io.RuneReader（ReadRune 方法） 和 io.RuneScanner（ReadRune 和 UnreadRune 方法）。</p>
<p>Reader结构如下：</p>
<pre><code class="go">type Reader struct {
    s        string    // Reader 读取的数据来源
    i        int // current reading index（当前读的索引位置）
    prevRune int // index of previous rune; or &lt; 0（前一个读取的 rune 索引位置）
}
</code></pre>
<p>可见 Reader 结构没有导出任何字段，而是提供一个实例化方法：</p>
<pre><code>func NewReader(s string) *Reader
</code></pre><p>该方法接收一个字符串，返回的 Reader 实例就是从该参数字符串读数据。bytes包中的 bytes.NewBufferString 功能类似，如果只为了读取，NewReader 效率会更好。</p>

                <hr>
                <div>
                    <p>
                         
                        <span class="badge badge-light">#&nbsp;Golang</span>
                        &nbsp;
                        
                    </p>
                </div>
                <br>
                
                    <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GNU GPL协议</a> 。转载请注明出处！</p>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">

    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk-container" style="width: 100%;">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({
            clientID: '5611c27bda66a636dd8f',
            clientSecret: 'f646fdf27383da58cc1da5a591160a0530b7bc38',
            id: location.pathname,
            repo: 'ss-xiong-blog-comments',
            owner: 'ss-xiong',
            admin: 'ss-xiong',
            labels: ['gitalk'],
            distractionFreeMode: 'true',
            createIssueManually: 'true',
            page: '20',
        })
        gitalk.render('gitalk-container')
    </script>
</div>
 
</div>
  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    
    <a href="https://github.com/ss-xiong" target="_blank">
      <b>SS-XIONG&copy;</b>
    </a>
    
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont">😘</i>
    <a href="https://github.com/invom/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    
    <script src="/js/post.js"></script>
    
      <script src="/js/plugins/prettify.js"></script>
      <script>
          $(document).ready(function(){
              $('pre').addClass('prettyprint linenums');
              prettyPrint();
          })
      </script>
    
  
</body>
</html>